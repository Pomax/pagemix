/**
 * The PageMixer is the master controll for both the
 * UI, content updates, and save/publish handling.
 * It delegates where necessary.
 */
class PageMixer {
    constructor(container) {
        this.events = new Listening();
        this.container = (container || document.body);
        this.bypass_key_input = false;
        // this order matters:
        this.overlay = this.getOverlay();
        this.editor = new Editor(this.events, this.overlay);
        this.pagemix = this.getMainMixer();
    }

    /**
     * Set up the UI and event listners
     */
    start() {
        let container = this.container;
        container.appendChild(this.pagemix);
        container.appendChild(this.overlay);

        let events = this.events;
        events.listen(document, 'click', e => this.edit(e));
        events.listen(document, 'mousemove', e => this.overrideMouseMove(e));
        events.listen(document, 'keyup', e => this.respondToKeys(e));

        this.running = true;
    }

    /**
     * Remove the UI and, crucially, remove all event listners
     * that were set up over the course of the page mixer running.
     */
    stop(e) {
        this.bypass_key_input = true;
        if (!confirm('turn off your page mixer?')) {
            setTimeout(() => (this.bypass_key_input=false), 100);
            return;
        }
        this.bypass_key_input = false;
        this.container.removeChild(this.overlay);
        this.container.removeChild(this.pagemix);
        this.events.dropListeners();
        this.running = false;
    }

    /**
     * The overlay is an absolutely positioned transparent div
     * without its own event handling so that it does not interfere
     * with locating the correct element under the cursor.
     */
    getOverlay() {
        let d = find('#pagemix-overlay');
        if (d) return d;
        d = create('div');
        d.id = 'pagemix-overlay';
        return d;
    }

    // utility function
    createButton(label, handler, options={}) {
        let button = create('button');
        button.id = `pagemix-${label}-button`;
        button.textContent = label;
        if (options.disabled) {
            button.disabled = true;
        }
        this.events.listen(button, 'click', handler);
        return button;
    }

    /**
     * The main button UI is just a strip of HTML button elements
     * with click handlers to the various supported operations.
     */
    getButtonBar() {
        let bar = find('#pagemix-controls');
        if (bar) return bar;

        bar = create('div');
        bar.id = 'pagemix-controls';
        bar.appendChild(this.createButton('parent',  e => this.selectParent(), {disabled: true}));
        bar.appendChild(this.createButton('delete',  e => this.delete(), {disabled: true}));
        bar.appendChild(this.createButton('undo',    e => this.undo()));
        bar.appendChild(this.createButton('redo',    e => this.redo()));
        bar.appendChild(this.createButton('help',    e => this.help()));
        bar.appendChild(this.createButton('save',    e => this.save()));
        bar.appendChild(this.createButton('publish', e => this.publish(), {disabled: true}));
        bar.appendChild(this.createButton('quit',    e => this.stop()));

        return bar;
    }

    /**
     * The main UI consist of a button bar, and an editor.
     */
    getMainMixer() {
        let pagemix = find('#pagemix-container');
        if (pagemix) return pagemix;

        pagemix = create('div');
        pagemix.id = 'pagemix-container';

        pagemix.appendChild(this.getButtonBar());
        pagemix.appendChild(this.editor.ui);

        //debug('returning pagemix container');
        return pagemix;
    }

    /**
     * Trigger a copy of an on-page element's outerHTML into the text
     * editor for inspection and manipulation. By loading up a part of
     * the page in the editor, the delete and publish operations become
     * meaningful and their associated buttons are enabled.
     *
     * @param {evt} the event generated by a click on an on-page element
     */
    edit(evt) {
        let t = evt.target;
        if (t === this.getOverlay()._related_element) {
            evt.preventDefault();
            evt.stopPropagation();
            this.editor.setRelatedElement(t);
            find('#pagemix-delete-button').disabled = false;
            find('#pagemix-parent-button').disabled = false;
            find('#pagemix-publish-button').disabled = false;
        }
    }

    /**
     * This selects the currently selected element's parentNode.
     */
    selectParent() {
        let parent = this.editor._related_element.parentNode;
        this.overlayOnElement(parent);
        this.edit({
            target: parent,
            preventDefault: () => {},
            stopPropagation: () => {}
        });
    }

    /**
     * Determine the element most immediately located under the
     * cursor, and size-and-position the overlay div to match,
     * so that it can act as a visual cue for which part of the
     * page will get loaded into the text editor when clicked.
     *
     * @param {evt} the event generated by moving the mouse cursor on the page
     */
    overrideMouseMove(evt) {
        let e = document.elementFromPoint(evt.clientX, evt.clientY);
        if (hasParent(e, this.getMainMixer())) return;
        if (hasParent(e, find('#pagemix-modal-underlay'))) return;
        evt.preventDefault();
        evt.stopPropagation();
        this.overlayOnElement(e);
        return false;
    }

    /**
     * Match the overlay dimensions and position on the page to
     * the element that we're supposed to be highlighting for.
     * @param {e} The DOM fragment we should be highlighting.
     */
    overlayOnElement(e) {
        let bbox = e.getBoundingClientRect();
        let d = this.getOverlay();
        ['right','bottom','width','height'].forEach(p => (d.style[p] = bbox[p] + 'px'));
        d.style.top = (bbox.top + window.pageYOffset) + "px"
        d.style.left = (bbox.left + window.pageXOffset) + "px"
        d._related_element = e;
    }

    /**
     * Respond to key presses on the page, notably the escape and
     * "x" keys, both of which will attempt to quit the page mixer.
     *
     * @param {evt} the event generated by pressing a key on the page
     */
    respondToKeys(evt) {
        if (this.bypass_key_input) return;

        let e = evt.target;
        if (hasParent(e, this.getMainMixer())) return;

        let k = evt.key,
            kc = evt.keyCode;

        if (kc === 27) { // escape key
            evt.preventDefault();
            evt.stopPropagation();
            this.stop();
        }
    }

    /**
     * Delete the original DOM element associated with the currently loaded code.
     * This is a convenience function, but cannot be undone.
     */
    delete() {
        if(confirm(`Are you sure you want to delete this part of the page?\n(You can't undo this one!)`)) {
            let e = this.editor.unsetRelatedElement();
            remove(e);
            find('#pagemix-parent-button').disabled = true;
            find('#pagemix-delete-button').disabled = true;
        }
    }

    // fall-through to editor undo
    undo(e) {
        this.editor.undo();
    }

    // fall-through to editor redo
    redo(e) {
        this.editor.redo();
    }

    /**
     * Save the current page, in its (possibly) edited state,
     * to the user's local machine. This is done by turning the
     * DOM into a download link, then triggering that link so the
     * user is presented with a normal browser "save or open" dialog.
     */
    save(e) {
        let filename = this.getFileName();
        let data = this.getPageCode();
        this.triggerDownload(filename, data);
    }

    /**
     * A utility function. We hash the filename based on the URL
     * and the time of save, so that the same page can be edited
     * and saved multiple times without overwriting the previous
     * edits.
     */
    getFileName() {
        let loc = md5(window.location.href + Date.now());
        return `${loc}.html`;
    }

    /**
     * Retrieve all CSS rules that were set up for this document
     * through stylesheets, rather than through inline styling.
     */
    getPageCSS() {
        let css = [];
        Array.from(document.styleSheets).forEach(s => {
            Array.from(s.cssRules).forEach(r => {
                css.push(r.cssText);
            });
        });
        return css.join('\n');
    }

    /**
     * If we're capturing styles from the stylesheet collection,
     * we don't want to keep the <link rel="stylesheet"> around
     * for the sheets that we got the the styles from, because that
     * would just incur pointless data transfers.
     */
    removeStyleSheets(dom) {
        Array.from(find("link[rel=stylesheet]", dom)).forEach(e => remove(e));
    }

    /**
     * It would be bad form to allow saving the HTML without making
     * a note that this is a custom edit of an existing page, so
     * the page code returned by this function includes a top-bar
     * that makes sure the data cannot be confused for the original.
     */
    getPageCode() {
        let html = find("html");
        // remove all the pagemix elements
        let copy = html.cloneNode(true);
        remove(find("#pagemix-container", copy));
        remove(find("#pagemix-overlay", copy));
        // but add a header to say this was a remix and what the original url was.
        let banner = create("div", `This is a remix of the page originally found at: <a href="${window.location.href}">${window.location.href}</a>`);
        banner.setAttribute('class', 'pagemix-banner');
        let style = create('style',`
            .pagemix-banner {
                position:fixed;
                top:0;
                left:0;
                right:0;
                background: #132e30;
                opacity: 0.7;
                color: white;
                text-align: center;
                font-family: Arial;
                z-index: 2147483647;
            }
            .pagemix-banner a,
            .pagemix-banner a:visited,
            .pagemix-banner a:hover,
            .pagemix-banner a:focus
             {
                 color: #b2b3a7;
             }
        `);
        banner.appendChild(style);
        let body = find('body', copy);
        body.insertBefore(banner, body.children[0]);

        // also, make sure there is a <base> so relative stuff resolves "normally"
        let base = create("base");
        base.href = window.location.href;
        let head = find('head', copy);
        head.appendChild(base);

        // And make sure the CSS gets explicitly added as a <style> element,
        // because requesting external CSS is going to fail a lot of the time.
        let css = create("style");
        css.textContent = this.getPageCSS();
        this.removeStyleSheets(copy);
        head.appendChild(css);

        // And finally, because this might be a saved file, never having
        // an associated website, we need to shim window.site
        let shim = create("script");
        shim.textContent = `if (!window.site) window.site = {};\n`;
        head.insertBefore(shim, head.children[0]);

        // then return the HTML code for this page
        return copy.outerHTML;
    }

    // utility function
    triggerDownload(filename, data) {
        let a = create("a");
        a.style.display = 'none';
        a.download = filename;
        a.href = `data:text/plain;charset=utf-8,${encodeURIComponent(data)}`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => remove(a), 1000);
    }

    help(e) {
        new HelpMenu(this.events);
    }

    /**
     * Initiate a publish-to-github action,
     * falling through to the Publisher
     */
    publish() {
        let filename = this.getFileName();
        let data = this.getPageCode();
        let publisher = this.publisher;
        if (!publisher) {
            publisher = this.publisher = new Publisher(this.events);
        }
        publisher.publish(filename, data);
    }
}